<html>
<head>
    <meta charset="utf-8">
    <title>大创知识图谱</title>
</head>

<style>
    body {
        background-color: #272b30;
        padding: 30px 40px;
        text-align: center;
        font-family: OpenSans-Light, PingFang SC, Hiragino Sans GB, Microsoft Yahei, Microsoft Jhenghei, sans-serif;
    }
    .nodes circle {
        stroke: #ffffff;
        stroke-width: 1.5px;
    }

    .links line {
        stroke: rgb(240,240,240);
        stroke-opacity: 0.8;
    }

    .links line.inactive,
    .nodes circle.inactive,
    .texts text.inactive
    {
        display: none;
    }



    .texts text {
        /*display: none;*/
        color: red;
    }
    .texts text:hover {
        cursor: pointer;
    }


</style>
<body>
    <div>
        <svg width="800" height="560" id="svg1"></svg>
        <div id="search1">
            <input type="text" class="form-control">
        </div>
    </div>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
<script>
    //选中要显示我们可视化图像的元素
    let svg = d3.select("#svg1"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

    let simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function(d) {
            return d.index;
        }))
        .force('collide', d3.forceCollide().radius(() => 10)) // collide 为节点指定一个radius区域来防止节点重叠。
        .force("charge", d3.forceManyBody().strength(-200))
        .force("center", d3.forceCenter(width / 2, height / 2-70));
    if (window.XMLHttpRequest)
    {// code for IE7+, Firefox, Chrome, Opera, Safari
        xmlhttp=new XMLHttpRequest();
    }
    else
    {// code for IE6, IE5
        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
    }
    xmlhttp.open("GET","../../spider/data.xml",false);
    xmlhttp.send();
    xmlDoc=xmlhttp.responseXML;

    // 设置节点
    nodes = [];
    let data = xmlDoc.getElementsByTagName("name");
    for (let i = 0;i < data.length;i++){
        nodes.push({name:data[i].childNodes[0].nodeValue})
    }

    let node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("circle")
        .data(nodes)
        .enter().append("circle")
        .attr("r", 20)
        .attr("fill", function(d) {
            // return color(d.group);
            return "#6ca46c";
        })
        .attr('stroke', 'none')
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

    let dragging = false;

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        dragging = true;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
        dragging = false;
    }

    simulation
        .nodes(nodes)
        .on("tick", ticked);

    // 设置节点之间的连线
    edges = [];
    data = xmlDoc.getElementsByTagName("item");
    for (let i=0;i<data.length;i++){
        edges.push({
            source:parseInt(data[i].childNodes[1].childNodes[0].nodeValue),
            target:parseInt(data[i].childNodes[3].childNodes[0].nodeValue)})
    }
    let link = svg.append("g")
        .attr("class","links")
        .selectAll("line")
        .data(edges)
        .enter().append("line")
        .attr("stroke-width",function (d) {
            return 1;
        });
    simulation.force("link")
        .links(edges);


    //设置节点上显示的文本
    let text = svg.append("g")
        .attr("class", "texts")
        .selectAll("text")
        .data(nodes)
        .enter().append("text")
        .attr("font-size", function(d) {
            return "13px";
        })
        .attr("fill", function(d) {
            // return color(d.group);
            return "#ff0000";
        })
        .attr('name', function(d) {
            return d.name;
        })
        .text(function(d) {
            return d.name;
        })
        .attr('text-anchor', 'middle')
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));


    function ticked() {
        link
            .attr("x1", function(d) {
                return d.source.x;
            })
            .attr("y1", function(d) {
                return d.source.y;
            })
            .attr("x2", function(d) {
                return d.target.x;
            })
            .attr("y2", function(d) {
                return d.target.y;
            });
        node.attr("cx", function(d) {
                return d.x;
            })
            .attr("cy", function(d) {
                return d.y;
            });

        text.
        attr('transform', function(d) {
            return 'translate(' + d.x + ',' + (d.y) + ')';
        });
    }

    // 处理搜索框，实现搜索功能
    $('#search1 input').keyup(function(event) {
        if ($(this).val() == '') {
            d3.select('#svg1 .texts').selectAll('text').attr('class', '');
            d3.select('#svg1 .nodes').selectAll('circle').attr('class', '');
            d3.select('#svg1 .links').selectAll('line').attr('class', '');
        } else {
            var name = $(this).val();
            d3.select('#svg1 .nodes').selectAll('circle').attr('class', function (d) {
                //找到包含包含输入的变量,显示,否则不显示
                if (d.name.indexOf(name) >= 0) {
                    return '';
                } else {
                    /*d.name代表当前节点的内容*/
                    if (d.name == name) {
                        return '';
                    }

                    for (let i = 0; i < edges.length; i++) {
                        if (edges[i]['source'].name.indexOf(d.name)>=0 && edges[i]['target'].name.indexOf(name)>=0) {
                            return '';
                        }
                        if (edges[i]['target'].name.indexOf(d.name)>=0 && edges[i]['source'].name.indexOf(name)>=0) {
                            return '';
                        }
                    }
                    return 'inactive';
                }




            });
            d3.select('#svg1 .texts').selectAll('text').attr('class', function (d) {

                if (d.name.indexOf(name) >= 0) {
                    return '';
                } else {
                    for (let i = 0; i < edges.length; i++) {
                        if (edges[i]['source'].name.indexOf(d.name) >= 0 && edges[i]['target'].name.indexOf(name) >= 0) {
                            return '';
                        }
                        if (edges[i]['target'].name.indexOf(d.name) >= 0 && edges[i]['source'].name.indexOf(name) >= 0) {
                            return '';
                        }
                    }
                }
                return 'inactive';
            });
            d3.select("#svg1 .links").selectAll('line').attr('class', function (d) {
                for (let i = 0; i < edges.length; i++) {
                    if (d['source'].name.indexOf(name)>=0||d['target'].name.indexOf(name)>=0) {
                        return '';
                    }
                }
                return 'inactive';
            });
        }
    });
</script>

</body>
</html>
